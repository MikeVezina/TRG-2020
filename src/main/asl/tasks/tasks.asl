/****** Task Rules ********/

getOldTask(CUR_TASK, OLD_TASK)
    :-  taskAssignment(_, OLD_TASK, _) &
        OLD_TASK \== CUR_TASK.

selfTaskAssignment(TASK, REQ)
    :-  not(.ground(TASK)) &
        not(.ground(REQ)) &
        .my_name(NAME) &
        taskAssignment(NAME, TASK, REQ).


// This event is generated by the operator
// and occurs when the task is no longer valid (either gets completed or expired).
@task_invalid[atomic]
+taskInvalid(TASK)[source(operator)]
    :   .ground(TASK)
    <-  .print("Task ", TASK, " is invalid.");
        .abolish(taskAssignment(_, TASK, _));
        .drop_desire(achieveTasks); // We must drop and restart this intention, otherwise the agent will continue with an old task
        !!achieveTasks.

+taskAssignment(_, TASK, _)[source(operator)]
    :   .findall(OLD, getOldTask(TASK, OLD), OLD_TASKS) &
        not(.length(OLD_TASKS, 0))
    <-  .print("Removing Old tasks.");
        !removeTasks(OLD_TASKS).

+!removeTasks(TASK_LIST)
    :  .list(TASK_LIST) &
        not(.length(TASK_LIST, 0))
    <-  for(.member(OLD, TASK_LIST))
        {
            .print("Removing task: ", OLD);
            .abolish(taskAssignment(_, OLD, _));
        }.

// When no task is available, the agents should explore the map and look for each other!
+!achieveTasks
    :   not(selfTaskAssignment(_, _))
    <-  !explore;
        !achieveTasks.

+resetTask(TASK)
    :   taskAssignment(_, TASK, _)
    <-  .print("Reset Task ", TASK);
        .drop_desire(achieveTasks); // We must drop and restart this intention, otherwise the agent will continue with an old task
        !!achieveTasks;
        -resetTask(TASK).

+!achieveTasks
    :   selfTaskAssignment(TASK, REQ)
    <-  .print("I've been assigned the task: ", TASK, " with requirement: ", REQ);
        !obtainRequirement(REQ);
        !deliverBlock(TASK, REQ).

//-!achieveTasks
//    :   selfTaskAssignment(TASK, _)
//    <-  .print("An Error Occured while achieving the task.");
//        .broadcast(tell, resetTask(TASK));
//        +resetTask(TASK).




// We only want to catch plan failures when we are achieving a task.
-!achieveTasks[error(E), error_msg(MSG), code(CODE), code_src(SRC), code_line(LINE)]
    :   selfTaskAssignment(TASK, REQ) & .current_intention(intention(_, Im))
        //&
//        E \== no_applicable &
//        E \== no_relevant &
//        E \== internal_action
    <-  .print("A Failure Occurred while achieving the current task.");
        .print("============");
        .print("Error Type: ", E);
        .print("Error Msg: ", MSG);
        .print("Code: ", CODE);
        .print("Code Src: ", SRC);
        .print("Code Line: ", LINE);
        .print("Intended Means: ", Im);
        .print("============");
        .wait(100); // Sleep before re-attempting
        !!achieveTasks. // Start in separate focus